<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>silly bean simulator</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      background: #f0f0f0;
    }
    #controls, #instructionUI, #imageControls {
      margin-top: 20px;
    }
    #canvas-container {
      margin: 20px auto;
      display: block;
      border: 1px solid #000;
      background: #fff;
      width: 600px;
      height: 600px;
    }
    label, input[type="button"] {
      margin: 5px;
    }
    .sliderContainer {
      margin: 10px 0;
    }
    input[type="text"] {
      width: 100px;
      text-align: center;
    }
    #softNodeIndices {
      background-color: #10ff15;
    }
  </style>
</head>
<body>
  <h1>silly bean simulator</h1>
  
  <div id="controls">
    <label>
      <input type="checkbox" id="gravityToggle" checked autocomplete="off"> Enable Gravity
    </label>
  </div>
  
  <!-- UI for instructing target positions -->
  <div id="instructionUI">
    <h2>Target Nodes</h2>
    <div>
      <!-- Updated node order with a new torso node:
           0: Torso Top (T1)
           1: Torso Middle (T2)
           2: Torso Bottom (T3)
           3: Head (H)
           4: Left Arm Upper (LA1)
           5: Left Arm Lower (LA2)
           6: Right Arm Upper (RA1)
           7: Right Arm Lower (RA2)
           8: Left Leg Upper (LL1)
           9: Left Leg Lower (LL2)
           10: Right Leg Upper (RL1)
           11: Right Leg Lower (RL2)
           12: Left Hand (LH)
           13: Right Hand (RH)
           14: Left Foot (LF)
           15: Right Foot (RF)
      -->
      <label>
        <input type="checkbox" value="0" class="target-checkbox" autocomplete="off"> Torso Top (T1)
      </label>
      <label>
        <input type="checkbox" value="1" class="target-checkbox" autocomplete="off"> Torso Middle (T2)
      </label>
      <label>
        <input type="checkbox" value="2" class="target-checkbox" autocomplete="off"> Torso Bottom (T3)
      </label>
      <label>
        <input type="checkbox" value="3" class="target-checkbox" autocomplete="off"> Head (H)
      </label>
      <label>
        <input type="checkbox" value="4" class="target-checkbox" autocomplete="off"> Left Arm Upper (LA1)
      </label>
      <label>
        <input type="checkbox" value="5" class="target-checkbox" autocomplete="off"> Left Arm Lower (LA2)
      </label>
      <label>
        <input type="checkbox" value="6" class="target-checkbox" autocomplete="off"> Right Arm Upper (RA1)
      </label>
      <label>
        <input type="checkbox" value="7" class="target-checkbox" autocomplete="off"> Right Arm Lower (RA2)
      </label>
      <label>
        <input type="checkbox" value="8" class="target-checkbox" autocomplete="off"> Left Leg Upper (LL1)
      </label>
      <label>
        <input type="checkbox" value="9" class="target-checkbox" autocomplete="off"> Left Leg Lower (LL2)
      </label>
      <label>
        <input type="checkbox" value="10" class="target-checkbox" autocomplete="off"> Right Leg Upper (RL1)
      </label>
      <label>
        <input type="checkbox" value="11" class="target-checkbox" autocomplete="off"> Right Leg Lower (RL2)
      </label>
      <label>
        <input type="checkbox" value="12" class="target-checkbox" autocomplete="off"> Left Hand (LH)
      </label>
      <label>
        <input type="checkbox" value="13" class="target-checkbox" autocomplete="off"> Right Hand (RH)
      </label>
      <label>
        <input type="checkbox" value="14" class="target-checkbox" autocomplete="off"> Left Foot (LF)
      </label>
      <label>
        <input type="checkbox" value="15" class="target-checkbox" autocomplete="off"> Right Foot (RF)
      </label>
    </div>
    <div class="sliderContainer">
      <label>
        Target X: <input type="range" id="targetX" min="0" max="600" value="300" autocomplete="off">
        <span id="targetXVal">300</span>
      </label>
    </div>
    <div class="sliderContainer">
      <label>
        Target Y: <input type="range" id="targetY" min="0" max="600" value="300" autocomplete="off">
        <span id="targetYVal">300</span>
      </label>
    </div>
    <input type="button" id="setTargetButton" value="Set Target" autocomplete="off">
    <input type="button" id="clearTargetsButton" value="Clear Targets" autocomplete="off">
  </div>

  <!-- UI for image attachments -->
  <div id="imageControls">
    <h2>Image Attachments</h2>
    <p>
      You can attach an image via URL and specify which nodes control it.
      In <strong>hard</strong> mode the image sticks to a single bone and now requires a separate node to point to.
      In <strong>soft</strong> mode the image is subdivided into a mesh and deformed based on a quadraticâ€“curve.
    </p>
    <div>
      <input type="button" id="setImgSrc" value="Set image source" autocomplete="off">
      <label>URL: 
        <input type="text" id="imgURLInput" value="https://example.com/image.png" autocomplete="off">
      </label>
    </div>
    <div>
      <!-- Updated hard image control now requires two node indices and a scale modifier -->
      <input type="button" id="addHardImage" value="Add Hard Image" autocomplete="off">
      <label>Attachment Node index: 
        <input type="text" id="hardAttachmentNode" value="3" autocomplete="off">
      </label>
      <label>Point-to Node index: 
        <input type="text" id="hardPointToNode" value="1" autocomplete="off">
      </label>
      <label>Scale: 
        <input type="text" id="hardImageScale" value="1" autocomplete="off">
      </label>
    </div>
    
    <div>
      <input type="button" id="addSoftImage" value="Add Soft Image" autocomplete="off">
      <label>Node indices (comma-separated): 
        <input type="text" id="softNodeIndices" value="0,1,2" autocomplete="off">
      </label>
    </div>
    <div>
      <input type="button" id="removeImagesButton" value="Remove All Images" autocomplete="off">
    </div>
  </div>
  
  <!-- Brain -->
  <div id="brainControls">
    <h2>brain controls</h2>
    <!-- toggle brain -->
    <label>Knock me out?</label>
    <input type="checkbox" id="brainOn" autocomplete="off">
  </div>
  
  <div id="canvas-container"></div>
  
  <!-- Matter.js library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <script>
    // Module aliases.
    let imgURL = null;
    const Engine = Matter.Engine,
          Render = Matter.Render,
          Runner = Matter.Runner,
          World = Matter.World,
          Bodies = Matter.Bodies,
          Constraint = Matter.Constraint,
          Events = Matter.Events,
          Vector = Matter.Vector,
          Body = Matter.Body;
    
    // Create engine.
    const engine = Engine.create();
    engine.world.gravity.y = 1; // default gravity
    
    // Create renderer.
    const render = Render.create({
      element: document.getElementById('canvas-container'),
      engine: engine,
      options: {
        width: 600,
        height: 600,
        wireframes: false,
        background: '#fff'
      }
    });
    Render.run(render);
    
    // Create runner.
    const runner = Runner.create();
    Runner.run(runner, engine);
    
    // --- Constants for Joint Limit Enforcement ---
    const K_HARD = 0.005;
    const K_SOFT = 0.0025;
    
    // --- Build the Humanoid Skeleton (Side View) ---
    // Define collision categories.
    const HEAD_CATEGORY = 0x0002;
    const TORSO_CATEGORY = 0x0004;
    const LEFT_ARM_CATEGORY = 0x0008;
    const RIGHT_ARM_CATEGORY = 0x0010;
    const LEFT_LEG_CATEGORY = 0x0020;
    const RIGHT_LEG_CATEGORY = 0x0040;
    
    // Create bodies for each section.
    // Torso (3 nodes):
    const torsoTop = Bodies.circle(300, 200, 10, {
      collisionFilter: { category: TORSO_CATEGORY, mask: TORSO_CATEGORY },
      render: { fillStyle: 'blue' }
    });
    const torsoMiddle = Bodies.circle(300, 225, 10, {
      collisionFilter: { category: TORSO_CATEGORY, mask: TORSO_CATEGORY },
      render: { fillStyle: 'blue' }
    });
    const torsoBottom = Bodies.circle(300, 250, 10, {
      collisionFilter: { category: TORSO_CATEGORY, mask: TORSO_CATEGORY },
      render: { fillStyle: 'blue' }
    });
    
    // Head (1 node):
    const head = Bodies.circle(330, 180, 10, {
      collisionFilter: { category: HEAD_CATEGORY, mask: HEAD_CATEGORY },
      render: { fillStyle: 'red' }
    });
    
    // Left Arm (2 nodes):
    const leftArmUpper = Bodies.circle(280, 200, 10, {
      collisionFilter: { category: LEFT_ARM_CATEGORY, mask: LEFT_ARM_CATEGORY },
      render: { fillStyle: 'orange' }
    });
    const leftArmLower = Bodies.circle(250, 210, 10, {
      collisionFilter: { category: LEFT_ARM_CATEGORY, mask: LEFT_ARM_CATEGORY },
      render: { fillStyle: 'orange' }
    });
    
    // Right Arm (2 nodes):
    const rightArmUpper = Bodies.circle(310, 200, 10, {
      collisionFilter: { category: RIGHT_ARM_CATEGORY, mask: RIGHT_ARM_CATEGORY },
      render: { fillStyle: 'green' }
    });
    const rightArmLower = Bodies.circle(320, 230, 10, {
      collisionFilter: { category: RIGHT_ARM_CATEGORY, mask: RIGHT_ARM_CATEGORY },
      render: { fillStyle: 'green' }
    });
    
    // Left Leg (2 nodes):
    const leftLegUpper = Bodies.circle(295, 300, 10, {
      collisionFilter: { category: LEFT_LEG_CATEGORY, mask: LEFT_LEG_CATEGORY },
      render: { fillStyle: 'purple' }
    });
    const leftLegLower = Bodies.circle(295, 350, 10, {
      collisionFilter: { category: LEFT_LEG_CATEGORY, mask: LEFT_LEG_CATEGORY },
      render: { fillStyle: 'purple' }
    });
    
    // Right Leg (2 nodes):
    const rightLegUpper = Bodies.circle(305, 300, 10, {
      collisionFilter: { category: RIGHT_LEG_CATEGORY, mask: RIGHT_LEG_CATEGORY },
      render: { fillStyle: 'brown' }
    });
    const rightLegLower = Bodies.circle(305, 350, 10, {
      collisionFilter: { category: RIGHT_LEG_CATEGORY, mask: RIGHT_LEG_CATEGORY },
      render: { fillStyle: 'brown' }
    });
    
    // New Nodes: Hands and Feet (smaller circles)
    const leftHand = Bodies.circle(230, 210, 6, {
      collisionFilter: { category: LEFT_ARM_CATEGORY, mask: LEFT_ARM_CATEGORY },
      render: { fillStyle: 'orange' }
    });
    const rightHand = Bodies.circle(340, 230, 6, {
      collisionFilter: { category: RIGHT_ARM_CATEGORY, mask: RIGHT_ARM_CATEGORY },
      render: { fillStyle: 'green' }
    });
    const leftFoot = Bodies.circle(295, 370, 6, {
      collisionFilter: { category: LEFT_LEG_CATEGORY, mask: LEFT_LEG_CATEGORY },
      render: { fillStyle: 'purple' }
    });
    const rightFoot = Bodies.circle(305, 370, 6, {
      collisionFilter: { category: RIGHT_LEG_CATEGORY, mask: RIGHT_LEG_CATEGORY },
      render: { fillStyle: 'brown' }
    });
    
    // Store all nodes (order matters for the targeting UI):
    const nodes = [
      torsoTop,     // 0
      torsoMiddle,  // 1
      torsoBottom,  // 2
      head,         // 3
      leftArmUpper, // 4
      leftArmLower, // 5
      rightArmUpper,// 6
      rightArmLower,// 7
      leftLegUpper, // 8
      leftLegLower, // 9
      rightLegUpper,// 10
      rightLegLower,// 11
      leftHand,     // 12
      rightHand,    // 13
      leftFoot,     // 14
      rightFoot     // 15
    ];
    
    // --- Define a hierarchy for node orientation ---
    const hierarchy = {
      0: { parent: null, children: [1, 3, 4, 6] },
      1: { parent: 0, children: [2] },
      2: { parent: 1, children: [8, 10] },
      3: { parent: 0, children: [] },
      4: { parent: 0, children: [5] },
      5: { parent: 4, children: [12] },
      6: { parent: 0, children: [7] },
      7: { parent: 6, children: [13] },
      8: { parent: 2, children: [9] },
      9: { parent: 8, children: [14] },
      10: { parent: 2, children: [11] },
      11: { parent: 10, children: [15] },
      12: { parent: 5, children: [] },
      13: { parent: 7, children: [] },
      14: { parent: 9, children: [] },
      15: { parent: 11, children: [] }
    };
    
    // --- Create constraints connecting the nodes. ---
    const constraints = [];
    
    function setJointLimits(constraint, jointType, deviationRange) {
      const dx = constraint.bodyB.position.x - constraint.bodyA.position.x;
      const dy = constraint.bodyB.position.y - constraint.bodyA.position.y;
      constraint.defaultAngle = Math.atan2(dy, dx);
      constraint.minAngle = constraint.defaultAngle - deviationRange;
      constraint.maxAngle = constraint.defaultAngle + deviationRange;
      constraint.jointType = jointType;
    }
    
    // Torso Constraints:
    const upperTorsoConstraint = Constraint.create({
      bodyA: torsoTop,
      bodyB: torsoMiddle,
      length: 25,
      stiffness: 1,
      render: { strokeStyle: '#555', lineWidth: 3 }
    });
    setJointLimits(upperTorsoConstraint, 'soft', 0.35);
    constraints.push(upperTorsoConstraint);
    
    const lowerTorsoConstraint = Constraint.create({
      bodyA: torsoMiddle,
      bodyB: torsoBottom,
      length: 25,
      stiffness: 1,
      render: { strokeStyle: '#555', lineWidth: 3 }
    });
    setJointLimits(lowerTorsoConstraint, 'soft', 0.35);
    constraints.push(lowerTorsoConstraint);
    
    // Neck.
    const neckConstraint = Constraint.create({
      bodyA: torsoTop,
      bodyB: head,
      length: 50,
      stiffness: 1,
      render: { strokeStyle: '#555', lineWidth: 3 }
    });
    setJointLimits(neckConstraint, 'soft', 0.52);
    constraints.push(neckConstraint);
    
    // Left Arm.
    const leftShoulder = Constraint.create({
      bodyA: torsoTop,
      bodyB: leftArmUpper,
      length: 40,
      stiffness: 1,
      render: { strokeStyle: '#555', lineWidth: 3 }
    });
    setJointLimits(leftShoulder, 'soft', 0.785);
    constraints.push(leftShoulder);
    
    const leftElbow = Constraint.create({
      bodyA: leftArmUpper,
      bodyB: leftArmLower,
      length: 40,
      stiffness: 1,
      render: { strokeStyle: '#555', lineWidth: 3 }
    });
    setJointLimits(leftElbow, 'hard', 0.52);
    constraints.push(leftElbow);
    
    // Right Arm.
    const rightShoulder = Constraint.create({
      bodyA: torsoTop,
      bodyB: rightArmUpper,
      length: 40,
      stiffness: 1,
      render: { strokeStyle: '#555', lineWidth: 3 }
    });
    setJointLimits(rightShoulder, 'soft', 0.785);
    constraints.push(rightShoulder);
    
    const rightElbow = Constraint.create({
      bodyA: rightArmUpper,
      bodyB: rightArmLower,
      length: 40,
      stiffness: 1,
      render: { strokeStyle: '#555', lineWidth: 3 }
    });
    setJointLimits(rightElbow, 'hard', 0.52);
    constraints.push(rightElbow);
    
    // Left Leg.
    const leftHip = Constraint.create({
      bodyA: torsoBottom,
      bodyB: leftLegUpper,
      length: 50,
      stiffness: 1,
      render: { strokeStyle: '#555', lineWidth: 3 }
    });
    setJointLimits(leftHip, 'soft', 0.785);
    constraints.push(leftHip);
    
    const leftKnee = Constraint.create({
      bodyA: leftLegUpper,
      bodyB: leftLegLower,
      length: 50,
      stiffness: 1,
      render: { strokeStyle: '#555', lineWidth: 3 }
    });
    setJointLimits(leftKnee, 'hard', 0.52);
    constraints.push(leftKnee);
    
    // Right Leg.
    const rightHip = Constraint.create({
      bodyA: torsoBottom,
      bodyB: rightLegUpper,
      length: 50,
      stiffness: 1,
      render: { strokeStyle: '#555', lineWidth: 3 }
    });
    setJointLimits(rightHip, 'soft', 0.785);
    constraints.push(rightHip);
    
    const rightKnee = Constraint.create({
      bodyA: rightLegUpper,
      bodyB: rightLegLower,
      length: 50,
      stiffness: 1,
      render: { strokeStyle: '#555', lineWidth: 3 }
    });
    setJointLimits(rightKnee, 'hard', 0.52);
    constraints.push(rightKnee);
    
    // Constraints for hands and feet.
    const leftHandConstraint = Constraint.create({
      bodyA: leftArmLower,
      bodyB: leftHand,
      length: 20,
      stiffness: 1,
      render: { strokeStyle: '#555', lineWidth: 3 }
    });
    setJointLimits(leftHandConstraint, 'hard', 0.35);
    constraints.push(leftHandConstraint);
    
    const rightHandConstraint = Constraint.create({
      bodyA: rightArmLower,
      bodyB: rightHand,
      length: 20,
      stiffness: 1,
      render: { strokeStyle: '#555', lineWidth: 3 }
    });
    setJointLimits(rightHandConstraint, 'hard', 0.35);
    constraints.push(rightHandConstraint);
    
    const leftFootConstraint = Constraint.create({
      bodyA: leftLegLower,
      bodyB: leftFoot,
      length: 20,
      stiffness: 1,
      render: { strokeStyle: '#555', lineWidth: 3 }
    });
    setJointLimits(leftFootConstraint, 'hard', 0.35);
    constraints.push(leftFootConstraint);
    
    const rightFootConstraint = Constraint.create({
      bodyA: rightLegLower,
      bodyB: rightFoot,
      length: 20,
      stiffness: 1,
      render: { strokeStyle: '#555', lineWidth: 3 }
    });
    setJointLimits(rightFootConstraint, 'hard', 0.35);
    constraints.push(rightFootConstraint);
    
    // Add nodes and constraints to the world.
    World.add(engine.world, nodes);
    World.add(engine.world, constraints);
    
    // --- Gravity Toggle ---
    const gravityToggle = document.getElementById('gravityToggle');
    gravityToggle.addEventListener('change', function() {
      engine.world.gravity.y = gravityToggle.checked ? 1 : 0;
    });
    
    // --- Boundaries ---
    const ALL_CATEGORIES = HEAD_CATEGORY | TORSO_CATEGORY | LEFT_ARM_CATEGORY | RIGHT_ARM_CATEGORY | LEFT_LEG_CATEGORY | RIGHT_LEG_CATEGORY;
    const boundaries = [
      Bodies.rectangle(300, 590, 600, 20, { 
        isStatic: true,
        collisionFilter: { category: ALL_CATEGORIES, mask: ALL_CATEGORIES },
        render: { fillStyle: '#6c757d' }
      }),
      Bodies.rectangle(300, 10, 600, 20, { 
        isStatic: true,
        collisionFilter: { category: ALL_CATEGORIES, mask: ALL_CATEGORIES },
        render: { fillStyle: '#cccccc' }
      }),
      Bodies.rectangle(10, 300, 20, 600, { 
        isStatic: true,
        collisionFilter: { category: ALL_CATEGORIES, mask: ALL_CATEGORIES },
        render: { fillStyle: '#cccccc' }
      }),
      Bodies.rectangle(590, 300, 20, 600, { 
        isStatic: true,
        collisionFilter: { category: ALL_CATEGORIES, mask: ALL_CATEGORIES },
        render: { fillStyle: '#cccccc' }
      })
    ];
    World.add(engine.world, boundaries);
    
    // --- Force-Driven Dragging (Mouse) ---
    let draggedBody = null;
    let dragTarget = null;
    
    function getMousePos(event) {
      const rect = render.canvas.getBoundingClientRect();
      return { x: event.clientX - rect.left, y: event.clientY - rect.top };
    }
    
    render.canvas.addEventListener('mousedown', function(event) {
      const mousePos = getMousePos(event);
      const bodies = Matter.Composite.allBodies(engine.world);
      const found = Matter.Query.point(bodies, mousePos);
      if (found.length > 0) {
        draggedBody = found[0];
        dragTarget = Vector.clone(mousePos);
      }
    });
    
    render.canvas.addEventListener('mousemove', function(event) {
      if (draggedBody) { dragTarget = getMousePos(event); }
    });
    render.canvas.addEventListener('mouseup', function() { draggedBody = null; dragTarget = null; });
    render.canvas.addEventListener('mouseleave', function() { draggedBody = null; dragTarget = null; });
    
    // --- Multi-Node Targeting ---
    let targetInstructions = { "3": { x: 300, y: 300 } };
    
    const targetXSlider = document.getElementById('targetX');
    const targetYSlider = document.getElementById('targetY');
    const targetXVal = document.getElementById('targetXVal');
    const targetYVal = document.getElementById('targetYVal');
    const setTargetButton = document.getElementById('setTargetButton');
    const clearTargetsButton = document.getElementById('clearTargetsButton');
    
    targetXSlider.addEventListener('input', function() { targetXVal.textContent = targetXSlider.value; });
    targetYSlider.addEventListener('input', function() { targetYVal.textContent = targetYSlider.value; });
    
    setTargetButton.addEventListener('click', function() {
      const checkboxes = document.querySelectorAll('.target-checkbox');
      checkboxes.forEach(cb => {
        if (cb.checked) {
          const idx = cb.value;
          targetInstructions[idx] = { x: parseFloat(targetXSlider.value), y: parseFloat(targetYSlider.value) };
        }
      });
    });
    
    clearTargetsButton.addEventListener('click', function() {
      targetInstructions = {};
      document.querySelectorAll('.target-checkbox').forEach(cb => cb.checked = false);
    });
    
    // --- Joint Limit Enforcement ---
    function enforceJointLimit(constraint) {
      const { bodyA, bodyB, defaultAngle, minAngle, maxAngle, jointType } = constraint;
      const dx = bodyB.position.x - bodyA.position.x;
      const dy = bodyB.position.y - bodyA.position.y;
      let currentAngle = Math.atan2(dy, dx);
      let angleDiff = currentAngle - defaultAngle;
      angleDiff = Math.atan2(Math.sin(angleDiff), Math.cos(angleDiff));
      
      let correction = 0;
      if (angleDiff < (minAngle - defaultAngle)) { correction = (minAngle - defaultAngle) - angleDiff; }
      else if (angleDiff > (maxAngle - defaultAngle)) { correction = (maxAngle - defaultAngle) - angleDiff; }
      if (correction !== 0) {
        const torque = (jointType === 'hard' ? K_HARD : K_SOFT) * correction;
        Body.setAngularVelocity(bodyA, bodyA.angularVelocity - torque);
        Body.setAngularVelocity(bodyB, bodyB.angularVelocity + torque);
      }
    }
    
    // --- Engine Update ---
    const forceFactor = 0.00005;
    Events.on(engine, 'beforeUpdate', function() {
      if (draggedBody && dragTarget) {
        const diff = Vector.sub(dragTarget, draggedBody.position);
        Body.applyForce(draggedBody, draggedBody.position, Vector.mult(diff, forceFactor));
      }
      for (const key in targetInstructions) {
        const idx = parseInt(key);
        const targetPos = targetInstructions[key];
        const body = nodes[idx];
        if (draggedBody === body) continue;
        const diff = Vector.sub(targetPos, body.position);
        Body.applyForce(body, body.position, Vector.mult(diff, forceFactor));
      }
      constraints.forEach(constraint => {
        if (constraint.jointType) { enforceJointLimit(constraint); }
      });
    });
    
    // --- Node Orientation Update ---
    Events.on(engine, 'afterUpdate', function() {
      for (let i = 0; i < nodes.length; i++) {
        let desiredAngle = 0;
        if (i === 0) {
          const dx = nodes[1].position.x - nodes[0].position.x;
          const dy = nodes[1].position.y - nodes[0].position.y;
          desiredAngle = Math.atan2(dy, dx);
        } else {
          const info = hierarchy[i];
          if (info.children.length === 1) {
            const childIndex = info.children[0];
            const dx = nodes[childIndex].position.x - nodes[i].position.x;
            const dy = nodes[childIndex].position.y - nodes[i].position.y;
            desiredAngle = Math.atan2(dy, dx);
          } else {
            const parentIndex = info.parent;
            if (parentIndex !== null) {
              const dx = nodes[i].position.x - nodes[parentIndex].position.x;
              const dy = nodes[i].position.y - nodes[parentIndex].position.y;
              desiredAngle = Math.atan2(dy, dx);
            }
          }
        }
        Body.setAngle(nodes[i], desiredAngle);
      }
    });
    
    // --- Image Attachment Functionality ---
    let imageAttachments = [];
    
    function addImageToBone(imageURL, nodeIndices, mode, scale) {
      const img = new Image();
      img.src = imageURL;
      img.onload = function() {
        if (mode === 'soft') {
          // Soft mode logic remains unchanged.
          const A = nodes[nodeIndices[0]].position;
          const C = nodes[nodeIndices[2]].position;
          const dx = C.x - A.x, dy = C.y - A.y;
          const baseHeight = Math.sqrt(dx*dx + dy*dy);
          const baseWidth = baseHeight * (img.width / img.height);
          const offCanvas = document.createElement('canvas');
          offCanvas.width = baseWidth;
          offCanvas.height = baseHeight;
          const offCtx = offCanvas.getContext('2d');
          offCtx.drawImage(img, 0, 0, baseWidth, baseHeight);
          imageAttachments.push({ image: offCanvas, nodes: nodeIndices, mode: mode, baseHeight: baseHeight, baseWidth: baseWidth });
        } else {
          // For hard mode, store the scale value.
          imageAttachments.push({ image: img, nodes: nodeIndices, mode: mode, scale: scale });
        }
      };
    }
    
    
    function drawTexturedTriangle(ctx, img, p0, p1, p2, t0, t1, t2) {
      const D = t0.x*(t1.y - t2.y) + t1.x*(t2.y - t0.y) + t2.x*(t0.y - t1.y);
      if (D === 0) return;
      const a = (p0.x*(t1.y - t2.y) + p1.x*(t2.y - t0.y) + p2.x*(t0.y - t1.y)) / D;
      const b = (p0.y*(t1.y - t2.y) + p1.y*(t2.y - t0.y) + p2.y*(t0.y - t1.y)) / D;
      const c = (p0.x*(t2.x - t1.x) + p1.x*(t0.x - t2.x) + p2.x*(t1.x - t0.x)) / D;
      const d = (p0.y*(t2.x - t1.x) + p1.y*(t0.x - t2.x) + p2.y*(t1.x - t0.x)) / D;
      const e = (p0.x*(t1.x*t2.y - t2.x*t1.y) + p1.x*(t2.x*t0.y - t0.x*t2.y) + p2.x*(t0.x*t1.y - t1.x*t0.y)) / D;
      const f = (p0.y*(t1.x*t2.y - t2.x*t1.y) + p1.y*(t2.x*t0.y - t0.x*t2.y) + p2.y*(t0.x*t1.y - t1.x*t0.y)) / D;
      
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(p0.x, p0.y);
      ctx.lineTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.closePath();
      ctx.clip();
      ctx.transform(a, b, c, d, e, f);
      ctx.drawImage(img, 0, 0);
      ctx.restore();
    }
    
    function drawSoftDeformedImage(ctx, attachment) {
      const img = attachment.image;
      const desiredHeight = attachment.baseHeight;
      const desiredWidth = attachment.baseWidth;
      
      const rows = 5, cols = 10;
      const dest = [];
      const tex = [];
      for (let i = 0; i <= rows; i++) {
        dest[i] = [];
        tex[i] = [];
        const v = i / rows;
        const cx = Math.pow(1-v,2)*nodes[attachment.nodes[0]].position.x +
                   2*(1-v)*v*nodes[attachment.nodes[1]].position.x +
                   Math.pow(v,2)*nodes[attachment.nodes[2]].position.x;
        const cy = Math.pow(1-v,2)*nodes[attachment.nodes[0]].position.y +
                   2*(1-v)*v*nodes[attachment.nodes[1]].position.y +
                   Math.pow(v,2)*nodes[attachment.nodes[2]].position.y;
        const tx = 2*(1-v)*(nodes[attachment.nodes[1]].position.x - nodes[attachment.nodes[0]].position.x) +
                   2*v*(nodes[attachment.nodes[2]].position.x - nodes[attachment.nodes[1]].position.x);
        const ty = 2*(1-v)*(nodes[attachment.nodes[1]].position.y - nodes[attachment.nodes[0]].position.y) +
                   2*v*(nodes[attachment.nodes[2]].position.y - nodes[attachment.nodes[1]].position.y);
        const len = Math.sqrt(tx*tx + ty*ty) || 1;
        const nx = -ty / len;
        const ny = tx / len;
        for (let j = 0; j <= cols; j++) {
          const u = j / cols;
          const offset = (u - 0.5) * desiredWidth;
          dest[i][j] = { x: cx + offset * nx, y: cy + offset * ny };
          tex[i][j] = { x: u * desiredWidth, y: v * desiredHeight };
        }
      }
      
      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          const p00 = dest[i][j], p10 = dest[i+1][j], p11 = dest[i+1][j+1], p01 = dest[i][j+1];
          const t00 = tex[i][j], t10 = tex[i+1][j], t11 = tex[i+1][j+1], t01 = tex[i][j+1];
          drawTexturedTriangle(ctx, img, p00, p10, p11, t00, t10, t11);
          drawTexturedTriangle(ctx, img, p00, p11, p01, t00, t11, t01);
        }
      }
    }
	
	
    
    Events.on(render, 'afterRender', function() {
      const ctx = render.context;
      imageAttachments.forEach(attachment => {
        if (attachment.mode === 'hard' && attachment.nodes.length === 2) {
          // For hard mode, use the first node as the attachment position and compute the angle toward the second node.
          const attachNode = nodes[attachment.nodes[0]];
          const pointToNode = nodes[attachment.nodes[1]];
          const angle = Math.atan2(pointToNode.position.y - attachNode.position.y,
                                     pointToNode.position.x - attachNode.position.x);
          const scale = attachment.scale || 1;
          const imgWidth = attachment.image.width * scale;
          const imgHeight = attachment.image.height * scale;
          ctx.save();
          ctx.translate(attachNode.position.x, attachNode.position.y);
          ctx.rotate(angle);
          ctx.drawImage(attachment.image, -imgWidth/2, -imgHeight/2, imgWidth, imgHeight);
          ctx.restore();
        } else if (attachment.mode === 'deform' && attachment.nodes.length === 3) {
          const p0 = nodes[attachment.nodes[0]].position;
          const p1 = nodes[attachment.nodes[1]].position;
          const p2 = nodes[attachment.nodes[2]].position;
          const t0 = { x: 0, y: 0 };
          const t1 = { x: attachment.image.width, y: 0 };
          const t2 = { x: 0, y: attachment.image.height };
          drawTexturedTriangle(ctx, attachment.image, p0, p1, p2, t0, t1, t2);
        } else if (attachment.mode === 'soft' && attachment.nodes.length === 3) {
          drawSoftDeformedImage(ctx, attachment);
        }
      });
    });
    
    // --- Image URL ---
    document.getElementById('setImgSrc').addEventListener('click', function() {
      imgURL = document.getElementById('imgURLInput').value;
    });

    // --- Example Image Attachment Buttons ---
    // Hard Image: now requires two node indices.
    document.getElementById('addHardImage').addEventListener('click', function() {
      const attachInput = document.getElementById('hardAttachmentNode').value;
      const pointToInput = document.getElementById('hardPointToNode').value;
      const scaleInput = document.getElementById('hardImageScale').value;
      const attachNodeIndex = parseInt(attachInput, 10);
      const pointToNodeIndex = parseInt(pointToInput, 10);
      const scale = parseFloat(scaleInput);
      if (isNaN(attachNodeIndex) || isNaN(pointToNodeIndex) || isNaN(scale)) {
        alert("Please provide valid node indices and a numeric scale value for the hard image.");
        return;
      }
      addImageToBone(imgURL, [attachNodeIndex, pointToNodeIndex], 'hard', scale);
    });
    
    
    
    document.getElementById('addSoftImage').addEventListener('click', function() {
      const indices = document.getElementById('softNodeIndices').value.split(',')
                        .map(s => parseInt(s.trim(), 10));
      addImageToBone(imgURL, indices, 'soft');
    });
    
    document.getElementById('removeImagesButton').addEventListener('click', function() {
      imageAttachments = [];
    });
    
    
    // --- Draw Node Indices ---
Events.on(render, 'afterRender', function() {
  const ctx = render.context;
  ctx.font = "12px sans-serif";
  ctx.fillStyle = "black";
  nodes.forEach((node, i) => {
    ctx.fillText(i, node.position.x + 8, node.position.y - 8);
  });
});

/*

// --- After nodes are defined, store each node's initial position ---
const initialPositions = nodes.map(node => ({ x: node.position.x, y: node.position.y }));

// --- Walking Animation Code Addressing All Nodes ---
let walkCycleActive = true;
let walkCycleTime = 0;

 // animateWalkingFull(delta)
 // This function computes a walking cycle (with a 2â€‘second period) that applies target offsets
 // to every node. The torso advances horizontally with a gentle vertical bobbing,
 // the head follows the torso, the arms swing opposite to each other, and the legs swing in counterâ€‘phases.
function animateWalkingFull(delta) {
  walkCycleTime += delta;
  const period = 2000; // Duration of one full cycle (in ms)
  const cycle = (walkCycleTime % period) / period; // Normalized cycle (0 to 1)
  const cycleRad = cycle * 2 * Math.PI;
  
  // Global horizontal forward movement:
  const walkSpeed = 0.05; // pixels per millisecond
  const globalX = walkCycleTime * walkSpeed;
  
  // Oscillation amplitudes:
  const bobAmplitude = 5;         // vertical bobbing for torso & head
  const armSwingAmplitude = 15;   // horizontal swing for arms
  const legSwingAmplitude = 15;   // horizontal swing for legs

  // --- Torso (nodes 0,1,2) ---
  [0, 1, 2].forEach(i => {
    targetInstructions[i] = {
      x: initialPositions[i].x + globalX,
      y: initialPositions[i].y + bobAmplitude * Math.sin(2 * cycleRad)
    };
  });

  // --- Head (node 3) ---
  targetInstructions[3] = {
    x: initialPositions[3].x + globalX,
    y: initialPositions[3].y + bobAmplitude * Math.sin(2 * cycleRad) - 2 // Slightly higher than torso bobbing
  };

  // --- Left Arm (nodes 4, 5, and left hand 12) ---
  [4, 5, 12].forEach(i => {
    targetInstructions[i] = {
      x: initialPositions[i].x + globalX + armSwingAmplitude * Math.sin(cycleRad),
      y: initialPositions[i].y
    };
  });

  // --- Right Arm (nodes 6, 7, and right hand 13) ---
  [6, 7, 13].forEach(i => {
    targetInstructions[i] = {
      x: initialPositions[i].x + globalX + armSwingAmplitude * Math.sin(cycleRad + Math.PI),
      y: initialPositions[i].y
    };
  });

  // --- Left Leg (nodes 8, 9, and left foot 14) ---
  [8, 9, 14].forEach(i => {
    targetInstructions[i] = {
      x: initialPositions[i].x + globalX + legSwingAmplitude * Math.sin(cycleRad),
      y: initialPositions[i].y
    };
  });

  // --- Right Leg (nodes 10, 11, and right foot 15) ---
  [10, 11, 15].forEach(i => {
    targetInstructions[i] = {
      x: initialPositions[i].x + globalX + legSwingAmplitude * Math.sin(cycleRad + Math.PI),
      y: initialPositions[i].y
    };
  });
}

// --- Engine Update: Call the full-body walking animation ---
Events.on(engine, 'beforeUpdate', function(event) {
  if (walkCycleActive) {
    animateWalkingFull(event.delta);
  }
  
  // --- Existing code for dragging and joint limit enforcement ---
  if (draggedBody && dragTarget) {
    const diff = Vector.sub(dragTarget, draggedBody.position);
    Body.applyForce(draggedBody, draggedBody.position, Vector.mult(diff, forceFactor));
  }
  for (const key in targetInstructions) {
    const idx = parseInt(key);
    const targetPos = targetInstructions[key];
    const body = nodes[idx];
    if (draggedBody === body) continue;
    const diff = Vector.sub(targetPos, body.position);
    Body.applyForce(body, body.position, Vector.mult(diff, forceFactor));
  }
  constraints.forEach(constraint => {
    if (constraint.jointType) { enforceJointLimit(constraint); }
  });
});


// Update the walking animation every engine update.
Events.on(engine, 'beforeUpdate', function(event) {
  if (walkCycleActive) {
    animateWalkingFull(event.delta);
  }
});
    
*/
  </script>


</body>
</html>
