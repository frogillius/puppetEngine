<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>silly bean simulator</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      background: #f0f0f0;
    }
    #controls, #instructionUI, #imageControls {
      margin-top: 20px;
    }
    #canvas-container {
      margin: 20px auto;
      display: block;
      border: 1px solid #000;
      background: #fff;
      width: 600px;
      height: 600px;
    }
    label, input[type="button"] {
      margin: 5px;
    }
    .sliderContainer {
      margin: 10px 0;
    }
    input[type="text"] {
      width: 100px;
      text-align: center;
    }
    #softNodeIndices {
      background-color: #10ff15;
    }
  </style>
</head>
<body>
  <h1>silly bean simulator</h1>
  
  <div id="controls">
    <label>
      <input type="checkbox" id="gravityToggle" checked autocomplete="off"> Enable Gravity
    </label>
  </div>
  
  <!-- UI for instructing target positions -->
  <div id="instructionUI">
    <h2>Target Nodes</h2>
    <div>
      <!-- Updated node order with a new torso node:
           0: Torso Top (T1)
           1: Torso Middle (T2)
           2: Torso Bottom (T3)
           3: Head (H)
           4: Left Arm Upper (LA1)
           5: Left Arm Lower (LA2)
           6: Right Arm Upper (RA1)
           7: Right Arm Lower (RA2)
           8: Left Leg Upper (LL1)
           9: Left Leg Lower (LL2)
           10: Right Leg Upper (RL1)
           11: Right Leg Lower (RL2)
           12: Left Hand (LH)
           13: Right Hand (RH)
           14: Left Foot (LF)
           15: Right Foot (RF)
      -->
      <label>
        <input type="checkbox" value="0" class="target-checkbox" autocomplete="off"> Torso Top (T1)
      </label>
      <label>
        <input type="checkbox" value="1" class="target-checkbox" autocomplete="off"> Torso Middle (T2)
      </label>
      <label>
        <input type="checkbox" value="2" class="target-checkbox" autocomplete="off"> Torso Bottom (T3)
      </label>
      <label>
        <input type="checkbox" value="3" class="target-checkbox" autocomplete="off"> Head (H)
      </label>
      <label>
        <input type="checkbox" value="4" class="target-checkbox" autocomplete="off"> Left Arm Upper (LA1)
      </label>
      <label>
        <input type="checkbox" value="5" class="target-checkbox" autocomplete="off"> Left Arm Lower (LA2)
      </label>
      <label>
        <input type="checkbox" value="6" class="target-checkbox" autocomplete="off"> Right Arm Upper (RA1)
      </label>
      <label>
        <input type="checkbox" value="7" class="target-checkbox" autocomplete="off"> Right Arm Lower (RA2)
      </label>
      <label>
        <input type="checkbox" value="8" class="target-checkbox" autocomplete="off"> Left Leg Upper (LL1)
      </label>
      <label>
        <input type="checkbox" value="9" class="target-checkbox" autocomplete="off"> Left Leg Lower (LL2)
      </label>
      <label>
        <input type="checkbox" value="10" class="target-checkbox" autocomplete="off"> Right Leg Upper (RL1)
      </label>
      <label>
        <input type="checkbox" value="11" class="target-checkbox" autocomplete="off"> Right Leg Lower (RL2)
      </label>
      <label>
        <input type="checkbox" value="12" class="target-checkbox" autocomplete="off"> Left Hand (LH)
      </label>
      <label>
        <input type="checkbox" value="13" class="target-checkbox" autocomplete="off"> Right Hand (RH)
      </label>
      <label>
        <input type="checkbox" value="14" class="target-checkbox" autocomplete="off"> Left Foot (LF)
      </label>
      <label>
        <input type="checkbox" value="15" class="target-checkbox" autocomplete="off"> Right Foot (RF)
      </label>
    </div>
    <div class="sliderContainer">
      <label>
        Target X: <input type="range" id="targetX" min="0" max="600" value="300" autocomplete="off">
        <span id="targetXVal">300</span>
      </label>
    </div>
    <div class="sliderContainer">
      <label>
        Target Y: <input type="range" id="targetY" min="0" max="600" value="300" autocomplete="off">
        <span id="targetYVal">300</span>
      </label>
    </div>
    <input type="button" id="setTargetButton" value="Set Target" autocomplete="off">
    <input type="button" id="clearTargetsButton" value="Clear Targets" autocomplete="off">
  </div>

  <!-- UI for image attachments -->
  <div id="imageControls">
    <h2>Image Attachments</h2>
    <p>
      You can attach an image via URL and specify which nodes control it.
      In <strong>hard</strong> mode the image sticks to a single bone and now requires a separate node to point to.
      In <strong>soft</strong> mode the image is subdivided into a mesh and deformed based on a quadratic–curve.
    </p>
    <div>
      <input type="button" id="setImgSrc" value="Set image source" autocomplete="off">
      <label>URL: 
        <input type="text" id="imgURLInput" value="https://example.com/image.png" autocomplete="off">
      </label>
    </div>
    <div>
      <!-- Updated hard image control now requires two node indices and a scale modifier -->
      <input type="button" id="addHardImage" value="Add Hard Image" autocomplete="off">
      <label>Attachment Node index: 
        <input type="text" id="hardAttachmentNode" value="3" autocomplete="off">
      </label>
      <label>Point-to Node index: 
        <input type="text" id="hardPointToNode" value="1" autocomplete="off">
      </label>
      <label>Scale: 
        <input type="text" id="hardImageScale" value="1" autocomplete="off">
      </label>
    </div>
    
    <div>
      <input type="button" id="addSoftImage" value="Add Soft Image" autocomplete="off">
      <label>Node indices (comma-separated): 
        <input type="text" id="softNodeIndices" value="0,1,2" autocomplete="off">
      </label>
    </div>
    <div>
      <input type="button" id="removeImagesButton" value="Remove All Images" autocomplete="off">
    </div>
  </div>
  
  <!-- Brain -->
  <div id="brainControls">
    <h2>brain controls</h2>
    <!-- toggle brain -->
    <label>Knock me out?</label>
    <input type="checkbox" id="brainOn" autocomplete="off">
  </div>
  
  <div id="canvas-container"></div>
  
  <!-- Matter.js library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <script>
    // Module aliases.
    let imgURL = null;
    const Engine = Matter.Engine,
          Render = Matter.Render,
          Runner = Matter.Runner,
          World = Matter.World,
          Bodies = Matter.Bodies,
          Constraint = Matter.Constraint,
          Events = Matter.Events,
          Vector = Matter.Vector,
          Body = Matter.Body;
    
    // Create engine.
    const engine = Engine.create();
    engine.world.gravity.y = 1; // default gravity
    
    // Create renderer.
    const render = Render.create({
      element: document.getElementById('canvas-container'),
      engine: engine,
      options: {
        width: 600,
        height: 600,
        wireframes: false,
        background: '#fff'
      }
    });
    Render.run(render);
    
    // Create runner.
    const runner = Runner.create();
    Runner.run(runner, engine);
    
    // --- Constants for Joint Limit Enforcement ---
    const K_HARD = 0.005;
    const K_SOFT = 0.0025;
    
    // --- Build the Humanoid Skeleton (Side View) ---
    // Define collision categories.
    const HEAD_CATEGORY = 0x0002;
    const TORSO_CATEGORY = 0x0004;
    const LEFT_ARM_CATEGORY = 0x0008;
    const RIGHT_ARM_CATEGORY = 0x0010;
    const LEFT_LEG_CATEGORY = 0x0020;
    const RIGHT_LEG_CATEGORY = 0x0040;
    
    // Create bodies for each section.
    // Torso (3 nodes):
    const torsoTop = Bodies.circle(300, 200, 10, {
      collisionFilter: { category: TORSO_CATEGORY, mask: TORSO_CATEGORY },
      render: { fillStyle: 'blue' }
    });
    const torsoMiddle = Bodies.circle(300, 225, 10, {
      collisionFilter: { category: TORSO_CATEGORY, mask: TORSO_CATEGORY },
      render: { fillStyle: 'blue' }
    });
    const torsoBottom = Bodies.circle(300, 250, 10, {
      collisionFilter: { category: TORSO_CATEGORY, mask: TORSO_CATEGORY },
      render: { fillStyle: 'blue' }
    });
    
    // Head (1 node):
    const head = Bodies.circle(330, 180, 10, {
      collisionFilter: { category: HEAD_CATEGORY, mask: HEAD_CATEGORY },
      render: { fillStyle: 'red' }
    });
    
    // Left Arm (2 nodes):
    const leftArmUpper = Bodies.circle(280, 200, 10, {
      collisionFilter: { category: LEFT_ARM_CATEGORY, mask: LEFT_ARM_CATEGORY },
      render: { fillStyle: 'orange' }
    });
    const leftArmLower = Bodies.circle(250, 210, 10, {
      collisionFilter: { category: LEFT_ARM_CATEGORY, mask: LEFT_ARM_CATEGORY },
      render: { fillStyle: 'orange' }
    });
    
    // Right Arm (2 nodes):
    const rightArmUpper = Bodies.circle(310, 200, 10, {
      collisionFilter: { category: RIGHT_ARM_CATEGORY, mask: RIGHT_ARM_CATEGORY },
      render: { fillStyle: 'green' }
    });
    const rightArmLower = Bodies.circle(320, 230, 10, {
      collisionFilter: { category: RIGHT_ARM_CATEGORY, mask: RIGHT_ARM_CATEGORY },
      render: { fillStyle: 'green' }
    });
    
    // Left Leg (2 nodes):
    const leftLegUpper = Bodies.circle(295, 300, 10, {
      collisionFilter: { category: LEFT_LEG_CATEGORY, mask: LEFT_LEG_CATEGORY },
      render: { fillStyle: 'purple' }
    });
    const leftLegLower = Bodies.circle(295, 350, 10, {
      collisionFilter: { category: LEFT_LEG_CATEGORY, mask: LEFT_LEG_CATEGORY },
      render: { fillStyle: 'purple' }
    });
    
    // Right Leg (2 nodes):
    const rightLegUpper = Bodies.circle(305, 300, 10, {
      collisionFilter: { category: RIGHT_LEG_CATEGORY, mask: RIGHT_LEG_CATEGORY },
      render: { fillStyle: 'brown' }
    });
    const rightLegLower = Bodies.circle(305, 350, 10, {
      collisionFilter: { category: RIGHT_LEG_CATEGORY, mask: RIGHT_LEG_CATEGORY },
      render: { fillStyle: 'brown' }
    });
    
    // New Nodes: Hands and Feet (smaller circles)
    const leftHand = Bodies.circle(230, 210, 6, {
      collisionFilter: { category: LEFT_ARM_CATEGORY, mask: LEFT_ARM_CATEGORY },
      render: { fillStyle: 'orange' }
    });
    const rightHand = Bodies.circle(340, 230, 6, {
      collisionFilter: { category: RIGHT_ARM_CATEGORY, mask: RIGHT_ARM_CATEGORY },
      render: { fillStyle: 'green' }
    });
    const leftFoot = Bodies.circle(295, 370, 6, {
      collisionFilter: { category: LEFT_LEG_CATEGORY, mask: LEFT_LEG_CATEGORY },
      render: { fillStyle: 'purple' }
    });
    const rightFoot = Bodies.circle(305, 370, 6, {
      collisionFilter: { category: RIGHT_LEG_CATEGORY, mask: RIGHT_LEG_CATEGORY },
      render: { fillStyle: 'brown' }
    });
    
    // Store all nodes (order matters for the targeting UI):
    const nodes = [
      torsoTop,     // 0
      torsoMiddle,  // 1
      torsoBottom,  // 2
      head,         // 3
      leftArmUpper, // 4
      leftArmLower, // 5
      rightArmUpper,// 6
      rightArmLower,// 7
      leftLegUpper, // 8
      leftLegLower, // 9
      rightLegUpper,// 10
      rightLegLower,// 11
      leftHand,     // 12
      rightHand,    // 13
      leftFoot,     // 14
      rightFoot     // 15
    ];
    
    // --- Define a hierarchy for node orientation ---
    const hierarchy = {
      0: { parent: null, children: [1, 3, 4, 6] },
      1: { parent: 0, children: [2] },
      2: { parent: 1, children: [8, 10] },
      3: { parent: 0, children: [] },
      4: { parent: 0, children: [5] },
      5: { parent: 4, children: [12] },
      6: { parent: 0, children: [7] },
      7: { parent: 6, children: [13] },
      8: { parent: 2, children: [9] },
      9: { parent: 8, children: [14] },
      10: { parent: 2, children: [11] },
      11: { parent: 10, children: [15] },
      12: { parent: 5, children: [] },
      13: { parent: 7, children: [] },
      14: { parent: 9, children: [] },
      15: { parent: 11, children: [] }
    };
    
    // --- Create constraints connecting the nodes. ---
    const constraints = [];
    
    function setJointLimits(constraint, jointType, deviationRange) {
      const dx = constraint.bodyB.position.x - constraint.bodyA.position.x;
      const dy = constraint.bodyB.position.y - constraint.bodyA.position.y;
      constraint.defaultAngle = Math.atan2(dy, dx);
      constraint.minAngle = constraint.defaultAngle - deviationRange;
      constraint.maxAngle = constraint.defaultAngle + deviationRange;
      constraint.jointType = jointType;
    }
    
    // Torso Constraints:
    const upperTorsoConstraint = Constraint.create({
      bodyA: torsoTop,
      bodyB: torsoMiddle,
      length: 25,
      stiffness: 1,
      render: { strokeStyle: '#555', lineWidth: 3 }
    });
    setJointLimits(upperTorsoConstraint, 'soft', 0.35);
    constraints.push(upperTorsoConstraint);
    
    const lowerTorsoConstraint = Constraint.create({
      bodyA: torsoMiddle,
      bodyB: torsoBottom,
      length: 25,
      stiffness: 1,
      render: { strokeStyle: '#555', lineWidth: 3 }
    });
    setJointLimits(lowerTorsoConstraint, 'soft', 0.35);
    constraints.push(lowerTorsoConstraint);
    
    // Neck.
    const neckConstraint = Constraint.create({
      bodyA: torsoTop,
      bodyB: head,
      length: 50,
      stiffness: 1,
      render: { strokeStyle: '#555', lineWidth: 3 }
    });
    setJointLimits(neckConstraint, 'soft', 0.52);
    constraints.push(neckConstraint);
    
    // Left Arm.
    const leftShoulder = Constraint.create({
      bodyA: torsoTop,
      bodyB: leftArmUpper,
      length: 40,
      stiffness: 1,
      render: { strokeStyle: '#555', lineWidth: 3 }
    });
    setJointLimits(leftShoulder, 'soft', 0.785);
    constraints.push(leftShoulder);
    
    const leftElbow = Constraint.create({
      bodyA: leftArmUpper,
      bodyB: leftArmLower,
      length: 40,
      stiffness: 1,
      render: { strokeStyle: '#555', lineWidth: 3 }
    });
    setJointLimits(leftElbow, 'hard', 0.52);
    constraints.push(leftElbow);
    
    // Right Arm.
    const rightShoulder = Constraint.create({
      bodyA: torsoTop,
      bodyB: rightArmUpper,
      length: 40,
      stiffness: 1,
      render: { strokeStyle: '#555', lineWidth: 3 }
    });
    setJointLimits(rightShoulder, 'soft', 0.785);
    constraints.push(rightShoulder);
    
    const rightElbow = Constraint.create({
      bodyA: rightArmUpper,
      bodyB: rightArmLower,
      length: 40,
      stiffness: 1,
      render: { strokeStyle: '#555', lineWidth: 3 }
    });
    setJointLimits(rightElbow, 'hard', 0.52);
    constraints.push(rightElbow);
    
    // Left Leg.
    const leftHip = Constraint.create({
      bodyA: torsoBottom,
      bodyB: leftLegUpper,
      length: 50,
      stiffness: 1,
      render: { strokeStyle: '#555', lineWidth: 3 }
    });
    setJointLimits(leftHip, 'soft', 0.785);
    constraints.push(leftHip);
    
    const leftKnee = Constraint.create({
      bodyA: leftLegUpper,
      bodyB: leftLegLower,
      length: 50,
      stiffness: 1,
      render: { strokeStyle: '#555', lineWidth: 3 }
    });
    setJointLimits(leftKnee, 'hard', 0.52);
    constraints.push(leftKnee);
    
    // Right Leg.
    const rightHip = Constraint.create({
      bodyA: torsoBottom,
      bodyB: rightLegUpper,
      length: 50,
      stiffness: 1,
      render: { strokeStyle: '#555', lineWidth: 3 }
    });
    setJointLimits(rightHip, 'soft', 0.785);
    constraints.push(rightHip);
    
    const rightKnee = Constraint.create({
      bodyA: rightLegUpper,
      bodyB: rightLegLower,
      length: 50,
      stiffness: 1,
      render: { strokeStyle: '#555', lineWidth: 3 }
    });
    setJointLimits(rightKnee, 'hard', 0.52);
    constraints.push(rightKnee);
    
    // Constraints for hands and feet.
    const leftHandConstraint = Constraint.create({
      bodyA: leftArmLower,
      bodyB: leftHand,
      length: 20,
      stiffness: 1,
      render: { strokeStyle: '#555', lineWidth: 3 }
    });
    setJointLimits(leftHandConstraint, 'hard', 0.35);
    constraints.push(leftHandConstraint);
    
    const rightHandConstraint = Constraint.create({
      bodyA: rightArmLower,
      bodyB: rightHand,
      length: 20,
      stiffness: 1,
      render: { strokeStyle: '#555', lineWidth: 3 }
    });
    setJointLimits(rightHandConstraint, 'hard', 0.35);
    constraints.push(rightHandConstraint);
    
    const leftFootConstraint = Constraint.create({
      bodyA: leftLegLower,
      bodyB: leftFoot,
      length: 20,
      stiffness: 1,
      render: { strokeStyle: '#555', lineWidth: 3 }
    });
    setJointLimits(leftFootConstraint, 'hard', 0.35);
    constraints.push(leftFootConstraint);
    
    const rightFootConstraint = Constraint.create({
      bodyA: rightLegLower,
      bodyB: rightFoot,
      length: 20,
      stiffness: 1,
      render: { strokeStyle: '#555', lineWidth: 3 }
    });
    setJointLimits(rightFootConstraint, 'hard', 0.35);
    constraints.push(rightFootConstraint);
    
    // Add nodes and constraints to the world.
    World.add(engine.world, nodes);
    World.add(engine.world, constraints);
    
    // --- Gravity Toggle ---
    const gravityToggle = document.getElementById('gravityToggle');
    gravityToggle.addEventListener('change', function() {
      engine.world.gravity.y = gravityToggle.checked ? 1 : 0;
    });
    
    // --- Boundaries ---
    const ALL_CATEGORIES = HEAD_CATEGORY | TORSO_CATEGORY | LEFT_ARM_CATEGORY | RIGHT_ARM_CATEGORY | LEFT_LEG_CATEGORY | RIGHT_LEG_CATEGORY;
    const boundaries = [
      Bodies.rectangle(300, 590, 600, 20, { 
        isStatic: true,
        collisionFilter: { category: ALL_CATEGORIES, mask: ALL_CATEGORIES },
        render: { fillStyle: '#6c757d' }
      }),
      Bodies.rectangle(300, 10, 600, 20, { 
        isStatic: true,
        collisionFilter: { category: ALL_CATEGORIES, mask: ALL_CATEGORIES },
        render: { fillStyle: '#cccccc' }
      }),
      Bodies.rectangle(10, 300, 20, 600, { 
        isStatic: true,
        collisionFilter: { category: ALL_CATEGORIES, mask: ALL_CATEGORIES },
        render: { fillStyle: '#cccccc' }
      }),
      Bodies.rectangle(590, 300, 20, 600, { 
        isStatic: true,
        collisionFilter: { category: ALL_CATEGORIES, mask: ALL_CATEGORIES },
        render: { fillStyle: '#cccccc' }
      })
    ];
    World.add(engine.world, boundaries);
    
    // --- Force-Driven Dragging (Mouse) ---
    let draggedBody = null;
    let dragTarget = null;
    
    function getMousePos(event) {
      const rect = render.canvas.getBoundingClientRect();
      return { x: event.clientX - rect.left, y: event.clientY - rect.top };
    }
    
    render.canvas.addEventListener('mousedown', function(event) {
      const mousePos = getMousePos(event);
      const bodies = Matter.Composite.allBodies(engine.world);
      const found = Matter.Query.point(bodies, mousePos);
      if (found.length > 0) {
        draggedBody = found[0];
        dragTarget = Vector.clone(mousePos);
      }
    });
    
    render.canvas.addEventListener('mousemove', function(event) {
      if (draggedBody) { dragTarget = getMousePos(event); }
    });
    render.canvas.addEventListener('mouseup', function() { draggedBody = null; dragTarget = null; });
    render.canvas.addEventListener('mouseleave', function() { draggedBody = null; dragTarget = null; });
    
    // --- Multi-Node Targeting ---
    let targetInstructions = { "3": { x: 300, y: 300 } };
    
    const targetXSlider = document.getElementById('targetX');
    const targetYSlider = document.getElementById('targetY');
    const targetXVal = document.getElementById('targetXVal');
    const targetYVal = document.getElementById('targetYVal');
    const setTargetButton = document.getElementById('setTargetButton');
    const clearTargetsButton = document.getElementById('clearTargetsButton');
    
    targetXSlider.addEventListener('input', function() { targetXVal.textContent = targetXSlider.value; });
    targetYSlider.addEventListener('input', function() { targetYVal.textContent = targetYSlider.value; });
    
    setTargetButton.addEventListener('click', function() {
      const checkboxes = document.querySelectorAll('.target-checkbox');
      checkboxes.forEach(cb => {
        if (cb.checked) {
          const idx = cb.value;
          targetInstructions[idx] = { x: parseFloat(targetXSlider.value), y: parseFloat(targetYSlider.value) };
        }
      });
    });
    
    clearTargetsButton.addEventListener('click', function() {
      targetInstructions = {};
      document.querySelectorAll('.target-checkbox').forEach(cb => cb.checked = false);
    });
    
    // --- Joint Limit Enforcement ---
    function enforceJointLimit(constraint) {
      const { bodyA, bodyB, defaultAngle, minAngle, maxAngle, jointType } = constraint;
      const dx = bodyB.position.x - bodyA.position.x;
      const dy = bodyB.position.y - bodyA.position.y;
      let currentAngle = Math.atan2(dy, dx);
      let angleDiff = currentAngle - defaultAngle;
      angleDiff = Math.atan2(Math.sin(angleDiff), Math.cos(angleDiff));
      
      let correction = 0;
      if (angleDiff < (minAngle - defaultAngle)) { correction = (minAngle - defaultAngle) - angleDiff; }
      else if (angleDiff > (maxAngle - defaultAngle)) { correction = (maxAngle - defaultAngle) - angleDiff; }
      if (correction !== 0) {
        const torque = (jointType === 'hard' ? K_HARD : K_SOFT) * correction;
        Body.setAngularVelocity(bodyA, bodyA.angularVelocity - torque);
        Body.setAngularVelocity(bodyB, bodyB.angularVelocity + torque);
      }
    }
    
    // --- Engine Update ---
    const forceFactor = 0.00005;
    Events.on(engine, 'beforeUpdate', function() {
      if (draggedBody && dragTarget) {
        const diff = Vector.sub(dragTarget, draggedBody.position);
        Body.applyForce(draggedBody, draggedBody.position, Vector.mult(diff, forceFactor));
      }
      for (const key in targetInstructions) {
        const idx = parseInt(key);
        const targetPos = targetInstructions[key];
        const body = nodes[idx];
        if (draggedBody === body) continue;
        const diff = Vector.sub(targetPos, body.position);
        Body.applyForce(body, body.position, Vector.mult(diff, forceFactor));
      }
      constraints.forEach(constraint => {
        if (constraint.jointType) { enforceJointLimit(constraint); }
      });
    });
    
    // --- Node Orientation Update ---
    Events.on(engine, 'afterUpdate', function() {
      for (let i = 0; i < nodes.length; i++) {
        let desiredAngle = 0;
        if (i === 0) {
          const dx = nodes[1].position.x - nodes[0].position.x;
          const dy = nodes[1].position.y - nodes[0].position.y;
          desiredAngle = Math.atan2(dy, dx);
        } else {
          const info = hierarchy[i];
          if (info.children.length === 1) {
            const childIndex = info.children[0];
            const dx = nodes[childIndex].position.x - nodes[i].position.x;
            const dy = nodes[childIndex].position.y - nodes[i].position.y;
            desiredAngle = Math.atan2(dy, dx);
          } else {
            const parentIndex = info.parent;
            if (parentIndex !== null) {
              const dx = nodes[i].position.x - nodes[parentIndex].position.x;
              const dy = nodes[i].position.y - nodes[parentIndex].position.y;
              desiredAngle = Math.atan2(dy, dx);
            }
          }
        }
        Body.setAngle(nodes[i], desiredAngle);
      }
    });
    
    // --- Image Attachment Functionality ---
    let imageAttachments = [];
    
    function addImageToBone(imageURL, nodeIndices, mode, scale) {
      // Convert string input to an array of numbers if needed.
      if (typeof nodeIndices === 'string') {
        nodeIndices = nodeIndices.split(',').map(s => parseInt(s.trim(), 10));
      }
    
      const img = new Image();
      img.src = imageURL;
      img.onload = function() {
        if (mode === 'soft') {
          const A_body = nodes[nodeIndices[0]];
          const B_body = nodes[nodeIndices[1]];
          const C_body = nodes[nodeIndices[2]];
          
          // Check that all nodes are defined.
          if (!A_body || !B_body || !C_body) {
            console.error("One or more node indices are invalid.", nodeIndices);
            return;
          }
          
          // Get the radii (or use default values)
          const radiusA = A_body.circleRadius || 10;
          const radiusC = C_body.circleRadius || 10;
          
          // Determine the bone lengths using the constraints.
          let boneDistance1 = 0;
          const constraintAB = constraints.find(c =>
            (c.bodyA === A_body && c.bodyB === B_body) ||
            (c.bodyB === A_body && c.bodyA === B_body)
          );
          if (constraintAB) {
            boneDistance1 = constraintAB.length;
          } else {
            const dx1 = B_body.position.x - A_body.position.x;
            const dy1 = B_body.position.y - A_body.position.y;
            boneDistance1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
          }
          
          let boneDistance2 = 0;
          const constraintBC = constraints.find(c =>
            (c.bodyA === B_body && c.bodyB === C_body) ||
            (c.bodyB === B_body && c.bodyA === C_body)
          );
          if (constraintBC) {
            boneDistance2 = constraintBC.length;
          } else {
            const dx2 = C_body.position.x - B_body.position.x;
            const dy2 = C_body.position.y - B_body.position.y;
            boneDistance2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
          }
          
          // Calculate the baseHeight as the sum of the bone lengths plus radii.
          const baseHeight = boneDistance1 + boneDistance2 + radiusA + radiusC;
          const baseWidth = baseHeight * (img.width / img.height);
          
          const offCanvas = document.createElement('canvas');
          offCanvas.width = baseWidth;
          offCanvas.height = baseHeight;
          const offCtx = offCanvas.getContext('2d');
          offCtx.drawImage(img, 0, 0, baseWidth, baseHeight);
          
          // Store the attachment details.
          imageAttachments.push({
            image: offCanvas,
            nodes: nodeIndices,
            mode: mode,
            baseHeight: baseHeight,
            baseWidth: baseWidth,
            radiusA: radiusA,
            radiusC: radiusC
          });
        } else {
          // For 'hard' mode
          imageAttachments.push({ image: img, nodes: nodeIndices, mode: mode, scale: scale });
        }
      };
    }
    
    
    
    function drawTexturedTriangle(ctx, img, p0, p1, p2, t0, t1, t2) {
      const D = t0.x*(t1.y - t2.y) + t1.x*(t2.y - t0.y) + t2.x*(t0.y - t1.y);
      if (D === 0) return;
      const a = (p0.x*(t1.y - t2.y) + p1.x*(t2.y - t0.y) + p2.x*(t0.y - t1.y)) / D;
      const b = (p0.y*(t1.y - t2.y) + p1.y*(t2.y - t0.y) + p2.y*(t0.y - t1.y)) / D;
      const c = (p0.x*(t2.x - t1.x) + p1.x*(t0.x - t2.x) + p2.x*(t1.x - t0.x)) / D;
      const d = (p0.y*(t2.x - t1.x) + p1.y*(t0.x - t2.x) + p2.y*(t1.x - t0.x)) / D;
      const e = (p0.x*(t1.x*t2.y - t2.x*t1.y) + p1.x*(t2.x*t0.y - t0.x*t2.y) + p2.x*(t0.x*t1.y - t1.x*t0.y)) / D;
      const f = (p0.y*(t1.x*t2.y - t2.x*t1.y) + p1.y*(t2.x*t0.y - t0.x*t2.y) + p2.y*(t0.x*t1.y - t1.x*t0.y)) / D;
      
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(p0.x, p0.y);
      ctx.lineTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.closePath();
      ctx.clip();
      ctx.transform(a, b, c, d, e, f);
      ctx.drawImage(img, 0, 0);
      ctx.restore();
    }
    
    function drawSoftDeformedImage(ctx, attachment) {
      const img = attachment.image;
      const desiredHeight = attachment.baseHeight;
      const desiredWidth = attachment.baseWidth;
    
      // Retrieve the three node bodies.
      const A_body = nodes[attachment.nodes[0]];
      const B_body = nodes[attachment.nodes[1]];
      const C_body = nodes[attachment.nodes[2]];
      const A = A_body.position;
      const B = B_body.position;
      const C = C_body.position;
    
      // Compute the normalized direction from A to C.
      const dx = C.x - A.x, dy = C.y - A.y;
      const dist = Math.sqrt(dx * dx + dy * dy) || 1;
      const dirX = dx / dist, dirY = dy / dist;
    
      // Adjust endpoints using the radii.
      const radiusA = attachment.radiusA;
      const radiusC = attachment.radiusC;
      const A_prime = { x: A.x - dirX * radiusA, y: A.y - dirY * radiusA };
      const C_prime = { x: C.x + dirX * radiusC, y: C.y + dirY * radiusC };
    
      // Compute the ideal midpoint (for a straight-line attachment)
      // and then adjust it by the deviation of B.
      const idealMid = { x: (A_prime.x + C_prime.x) / 2, y: (A_prime.y + C_prime.y) / 2 };
      const origMid = { x: (A.x + C.x) / 2, y: (A.y + C.y) / 2 };
      const deviation = { x: B.x - origMid.x, y: B.y - origMid.y };
      const curvatureFactor = 1; // set to 0 for a straight line
      const B_prime = {
        x: idealMid.x + curvatureFactor * deviation.x,
        y: idealMid.y + curvatureFactor * deviation.y
      };
    
      // --- Global Top/Bottom Edge Correction ---
      // Here we want to force the deformed grid’s top (v=0) and bottom (v=1)
      // rows to land exactly where they should.
      // We assume that in the “correct” (undeformed) mapping the spine is a straight line
      // running from A′ (top) to C′ (bottom). We define a horizontal (u) direction
      // as the unit vector perpendicular to that spine.
      const spineDX = C_prime.x - A_prime.x;
      const spineDY = C_prime.y - A_prime.y;
      const spineLen = Math.sqrt(spineDX * spineDX + spineDY * spineDY) || 1;
      // globalU is the horizontal direction (image’s x‑axis) for the attached image.
      const globalU = { x: -spineDY / spineLen, y: spineDX / spineLen };
    
      // For the top edge (v=0), the center is at A′.
      const topCenter = A_prime;
      const topLeft = {
        x: topCenter.x - (desiredWidth / 2) * globalU.x,
        y: topCenter.y - (desiredWidth / 2) * globalU.y
      };
      const topRight = {
        x: topCenter.x + (desiredWidth / 2) * globalU.x,
        y: topCenter.y + (desiredWidth / 2) * globalU.y
      };
    
      // For the bottom edge (v=1), the center is at C′.
      const bottomCenter = C_prime;
      const bottomLeft = {
        x: bottomCenter.x - (desiredWidth / 2) * globalU.x,
        y: bottomCenter.y - (desiredWidth / 2) * globalU.y
      };
      const bottomRight = {
        x: bottomCenter.x + (desiredWidth / 2) * globalU.x,
        y: bottomCenter.y + (desiredWidth / 2) * globalU.y
      };
    
      // --- Build the Deformed Grid ---
      // We use a (rows+1) x (cols+1) grid.
      const rows = 10, cols = 10;
      const dest = [];
      const tex = [];
      
      for (let i = 0; i <= rows; i++) {
        dest[i] = [];
        tex[i] = [];
        const v = i / rows;
    
        // Compute the quadratic-interpolated spine (center) for this row.
        const cx = Math.pow(1 - v, 2) * A_prime.x +
                   2 * (1 - v) * v * B_prime.x +
                   Math.pow(v, 2) * C_prime.x;
        const cy = Math.pow(1 - v, 2) * A_prime.y +
                   2 * (1 - v) * v * B_prime.y +
                   Math.pow(v, 2) * C_prime.y;
        
        // Compute the local tangent of the spine.
        const tx = 2 * (1 - v) * (B_prime.x - A_prime.x) +
                   2 * v * (C_prime.x - B_prime.x);
        const ty = 2 * (1 - v) * (B_prime.y - A_prime.y) +
                   2 * v * (C_prime.y - B_prime.y);
        const tangentLen = Math.sqrt(tx * tx + ty * ty) || 1;
        const localNormal = { x: -ty / tangentLen, y: tx / tangentLen };
    
        for (let j = 0; j <= cols; j++) {
          const u = j / cols;
          const offsetVal = (u - 0.5) * desiredWidth;
          // This is the original computed position from the quadratic curve.
          const computedPos = {
            x: cx + offsetVal * localNormal.x,
            y: cy + offsetVal * localNormal.y
          };
    
          // --- Global (edge-corrected) position for top/bottom ---
          // For each column (fixed u), determine where the vertex should be if
          // the top and bottom edges were forced to their correct positions.
          // Compute the top edge position at this u:
          const topPos = {
            x: topLeft.x + u * (topRight.x - topLeft.x),
            y: topLeft.y + u * (topRight.y - topLeft.y)
          };
          // And the bottom edge position at this u:
          const bottomPos = {
            x: bottomLeft.x + u * (bottomRight.x - bottomLeft.x),
            y: bottomLeft.y + u * (bottomRight.y - bottomLeft.y)
          };
          // Interpolate between top and bottom based on v.
          const globalPos = {
            x: (1 - v) * topPos.x + v * bottomPos.x,
            y: (1 - v) * topPos.y + v * bottomPos.y
          };
    
          // --- Blend the positions ---
          // We want the top (v=0) and bottom (v=1) rows to use the globalPos exactly,
          // while the midline (v=0.5) can use the computedPos.
          // Here we use a blending factor that is 1 at v=0 and v=1 and 0 at v=0.5.
          const edgeFactor = 1 - Math.sin(Math.PI * v); // sin(0)=0, sin(pi/2)=1, sin(pi)=0
          const finalPos = {
            x: computedPos.x * (1 - edgeFactor) + globalPos.x * edgeFactor,
            y: computedPos.y * (1 - edgeFactor) + globalPos.y * edgeFactor
          };
    
          dest[i][j] = finalPos;
          tex[i][j] = { x: u * desiredWidth, y: v * desiredHeight };
        }
      }
    
      // --- Draw the Deformed Image ---
      // Subdivide the grid into triangles and draw textured triangles.
      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          const p00 = dest[i][j],
                p10 = dest[i + 1][j],
                p11 = dest[i + 1][j + 1],
                p01 = dest[i][j + 1];
          const t00 = tex[i][j],
                t10 = tex[i + 1][j],
                t11 = tex[i + 1][j + 1],
                t01 = tex[i][j + 1];
          drawTexturedTriangle(ctx, img, p00, p10, p11, t00, t10, t11);
          drawTexturedTriangle(ctx, img, p00, p11, p01, t00, t11, t01);
        }
      }
    }
    
    
    
	
	
    
    Events.on(render, 'afterRender', function() {
      const ctx = render.context;
      imageAttachments.forEach(attachment => {
        if (attachment.mode === 'hard' && attachment.nodes.length === 2) {
          // For hard mode, use the first node as the attachment position and compute the angle toward the second node.
          const attachNode = nodes[attachment.nodes[0]];
          const pointToNode = nodes[attachment.nodes[1]];
          const angle = Math.atan2(pointToNode.position.y - attachNode.position.y,
                                     pointToNode.position.x - attachNode.position.x);
          const scale = attachment.scale || 1;
          const imgWidth = attachment.image.width * scale;
          const imgHeight = attachment.image.height * scale;
          ctx.save();
          ctx.translate(attachNode.position.x, attachNode.position.y);
          ctx.rotate(angle);
          ctx.drawImage(attachment.image, -imgWidth/2, -imgHeight/2, imgWidth, imgHeight);
          ctx.restore();
        } else if (attachment.mode === 'deform' && attachment.nodes.length === 3) {
          const p0 = nodes[attachment.nodes[0]].position;
          const p1 = nodes[attachment.nodes[1]].position;
          const p2 = nodes[attachment.nodes[2]].position;
          const t0 = { x: 0, y: 0 };
          const t1 = { x: attachment.image.width, y: 0 };
          const t2 = { x: 0, y: attachment.image.height };
          drawTexturedTriangle(ctx, attachment.image, p0, p1, p2, t0, t1, t2);
        } else if (attachment.mode === 'soft' && attachment.nodes.length === 3) {
          drawSoftDeformedImage(ctx, attachment);
        }
      });
    });
    
    // --- Image URL ---
    document.getElementById('setImgSrc').addEventListener('click', function() {
      imgURL = document.getElementById('imgURLInput').value;
    });

    // --- Example Image Attachment Buttons ---
    // Hard Image: now requires two node indices.
    document.getElementById('addHardImage').addEventListener('click', function() {
      const attachInput = document.getElementById('hardAttachmentNode').value;
      const pointToInput = document.getElementById('hardPointToNode').value;
      const scaleInput = document.getElementById('hardImageScale').value;
      const attachNodeIndex = parseInt(attachInput, 10);
      const pointToNodeIndex = parseInt(pointToInput, 10);
      const scale = parseFloat(scaleInput);
      if (isNaN(attachNodeIndex) || isNaN(pointToNodeIndex) || isNaN(scale)) {
        alert("Please provide valid node indices and a numeric scale value for the hard image.");
        return;
      }
      addImageToBone(imgURL, [attachNodeIndex, pointToNodeIndex], 'hard', scale);
    });
    
    
    
    document.getElementById('addSoftImage').addEventListener('click', function() {
      const indices = document.getElementById('softNodeIndices').value.split(',')
                        .map(s => parseInt(s.trim(), 10));
      addImageToBone(imgURL, indices, 'soft');
    });
    
    document.getElementById('removeImagesButton').addEventListener('click', function() {
      imageAttachments = [];
    });
    
    
    // --- Draw Node Indices ---
Events.on(render, 'afterRender', function() {
  const ctx = render.context;
  ctx.font = "12px sans-serif";
  ctx.fillStyle = "black";
  nodes.forEach((node, i) => {
    ctx.fillText(i, node.position.x + 8, node.position.y - 8);
  });
});

// --- Draw Target Instructions ---
Events.on(render, 'afterRender', function() {
  const ctx = render.context;
  ctx.font = "12px sans-serif";
  ctx.fillStyle = "red";
  for (const key in targetInstructions) {
    const idx = parseInt(key);
    const targetPos = targetInstructions[key];
    ctx.fillText(key, targetPos.x, targetPos.y);
  }
});


// --- Define Textures ---
function intitializeTextures() {
  let url = "http://localhost:6969/testing/sbs/"
  let args = null;

  args = "0,1,2"
  addImageToBone(url+"torso/torso.png", args, "soft");

  /*
  args = "0,4"
  addImageToBone(url+"upperArm/upperArm.png", args, "hard", 0.05)
  */
}

intitializeTextures();
/*

// --- After nodes are defined, store each node's initial position ---
const initialPositions = nodes.map(node => ({ x: node.position.x, y: node.position.y }));

// --- Walking Animation Code Addressing All Nodes ---
let walkCycleActive = true;
let walkCycleTime = 0;

 // animateWalkingFull(delta)
 // This function computes a walking cycle (with a 2‑second period) that applies target offsets
 // to every node. The torso advances horizontally with a gentle vertical bobbing,
 // the head follows the torso, the arms swing opposite to each other, and the legs swing in counter‑phases.
function animateWalkingFull(delta) {
  walkCycleTime += delta;
  const period = 2000; // Duration of one full cycle (in ms)
  const cycle = (walkCycleTime % period) / period; // Normalized cycle (0 to 1)
  const cycleRad = cycle * 2 * Math.PI;
  
  // Global horizontal forward movement:
  const walkSpeed = 0.05; // pixels per millisecond
  const globalX = walkCycleTime * walkSpeed;
  
  // Oscillation amplitudes:
  const bobAmplitude = 5;         // vertical bobbing for torso & head
  const armSwingAmplitude = 15;   // horizontal swing for arms
  const legSwingAmplitude = 15;   // horizontal swing for legs

  // --- Torso (nodes 0,1,2) ---
  [0, 1, 2].forEach(i => {
    targetInstructions[i] = {
      x: initialPositions[i].x + globalX,
      y: initialPositions[i].y + bobAmplitude * Math.sin(2 * cycleRad)
    };
  });

  // --- Head (node 3) ---
  targetInstructions[3] = {
    x: initialPositions[3].x + globalX,
    y: initialPositions[3].y + bobAmplitude * Math.sin(2 * cycleRad) - 2 // Slightly higher than torso bobbing
  };

  // --- Left Arm (nodes 4, 5, and left hand 12) ---
  [4, 5, 12].forEach(i => {
    targetInstructions[i] = {
      x: initialPositions[i].x + globalX + armSwingAmplitude * Math.sin(cycleRad),
      y: initialPositions[i].y
    };
  });

  // --- Right Arm (nodes 6, 7, and right hand 13) ---
  [6, 7, 13].forEach(i => {
    targetInstructions[i] = {
      x: initialPositions[i].x + globalX + armSwingAmplitude * Math.sin(cycleRad + Math.PI),
      y: initialPositions[i].y
    };
  });

  // --- Left Leg (nodes 8, 9, and left foot 14) ---
  [8, 9, 14].forEach(i => {
    targetInstructions[i] = {
      x: initialPositions[i].x + globalX + legSwingAmplitude * Math.sin(cycleRad),
      y: initialPositions[i].y
    };
  });

  // --- Right Leg (nodes 10, 11, and right foot 15) ---
  [10, 11, 15].forEach(i => {
    targetInstructions[i] = {
      x: initialPositions[i].x + globalX + legSwingAmplitude * Math.sin(cycleRad + Math.PI),
      y: initialPositions[i].y
    };
  });
}

// --- Engine Update: Call the full-body walking animation ---
Events.on(engine, 'beforeUpdate', function(event) {
  if (walkCycleActive) {
    animateWalkingFull(event.delta);
  }
  
  // --- Existing code for dragging and joint limit enforcement ---
  if (draggedBody && dragTarget) {
    const diff = Vector.sub(dragTarget, draggedBody.position);
    Body.applyForce(draggedBody, draggedBody.position, Vector.mult(diff, forceFactor));
  }
  for (const key in targetInstructions) {
    const idx = parseInt(key);
    const targetPos = targetInstructions[key];
    const body = nodes[idx];
    if (draggedBody === body) continue;
    const diff = Vector.sub(targetPos, body.position);
    Body.applyForce(body, body.position, Vector.mult(diff, forceFactor));
  }
  constraints.forEach(constraint => {
    if (constraint.jointType) { enforceJointLimit(constraint); }
  });
});


// Update the walking animation every engine update.
Events.on(engine, 'beforeUpdate', function(event) {
  if (walkCycleActive) {
    animateWalkingFull(event.delta);
  }
});
    
*/
  </script>


</body>
</html>
