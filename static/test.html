<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Game Layout with Custom Default Sizes</title>
  <link rel="stylesheet" href="http://localhost:6969/static/themes/cobolt.css">

</head>
<body>
  <div id="gameWindow">
    <!-- Section 1: Encounter Area -->
    <div id="encounter" class="section">
      <div class="portrait" id="encounterPortrait">
        <iframe id="encounterIframe" src="portrait-all.html?config=fallback.json&width=100%&height=100%" width="100%" height="300px" scrolling="no" style="border-radius: 10px; border: none;"></iframe>
      </div>
      <div class="stats" id="encounterStats"></div>
    </div>

    <!-- Section 2: Stage Area (includes stage and dialog) -->
    <div id="stage" class="section">
      <div id="stageArea">
        <iframe id="stageIframe" src="stage.html?config=assets/rooms/test/test-room.json" width="100%" height="300px" scrolling="no" style="border-radius: 10px; border: none;"></iframe>
      </div>
      <div id="dialog"></div>
    </div>

    <!-- Section 3: Player Area -->
    <div id="player" class="section">
      <div class="portrait" id="playerPortrait">
        <iframe id="playerIframe" src="portrait-all.html?config=fallback.json&width=100%&height=100%" width="100%" height="300px" scrolling="no" style="border-radius: 10px; border: none;"></iframe>
      </div>
      <div class="stats" id="playerStats"></div>
    </div>
  </div>

  <!-- Include Split.js from a CDN -->
  <script src="https://unpkg.com/split.js/dist/split.min.js"></script>
  <script>
    // JSON configuration for modding (could be replaced with an external JSON fetch)
    const jsonData = {
      "encounter": {
        "stats": {
          "health": 100,
          "attack": 20,
          "defense": 15,
          "icon": "https://via.placeholder.com/30?text=Icon"
        }
      },
      "player": {
        "stats": {
          "health": 120,
          "attack": 25,
          "defense": 20,
          "icon": "https://via.placeholder.com/30?text=Icon"
        }
      },
      "stage": {
        "parallax": [
          {"layer": 1, "image": "https://via.placeholder.com/800x200?text=Layer+1"},
          {"layer": 2, "image": "https://via.placeholder.com/800x200?text=Layer+2"},
          {"layer": 3, "image": "https://via.placeholder.com/800x200?text=Layer+3"},
          {"layer": 4, "image": "https://via.placeholder.com/800x200?text=Layer+4"},
          {"layer": 5, "image": "https://via.placeholder.com/800x200?text=Layer+5"}
        ],
        "puppets": [
          {"id": "stagePuppet1", "image": "https://via.placeholder.com/100x200?text=Stage+Puppet", "position": {"left": "40%"}}
        ],
        "objects": [
          {
            "id": "object1",
            "image": "https://via.placeholder.com/50x50?text=Obj",
            "position": {"left": "60%"},
            "clickableAreas": [
              {"x": 10, "y": 10, "width": 30, "height": 30}
            ]
          }
        ]
      },
      "dialog": {
        "text": "Welcome to the game! Choose your action:",
        "buttons": [
          {"text": "Attack", "action": "attack()"},
          {"text": "Defend", "action": "defend()"}
        ]
      }
    };

    const iframe_e = document.getElementById('encounterIframe'); // encounter
    const iframe_p = document.getElementById('encounterIframe'); // player
    const iframe_s = document.getElementById('encounterIframe'); // stage

   // Wait for the iframe to load completely
   iframe_e.onload = () => {
        const iframeDocument = iframe.contentDocument || iframe.contentWindow.document;
        const iframeCanvas = iframeDocument.getElementById('sc-canvas');

        if (iframeCanvas) {
            // Transfer the content of iframe's canvas to OffscreenCanvas
            const offscreenCanvas = iframeCanvas.transferControlToOffscreen();

            // Send the OffscreenCanvas to the worker
            const worker = new Worker('offscreen-worker.js');
            worker.postMessage({ canvas: offscreenCanvas }, [offscreenCanvas]);

            worker.onmessage = function(event) {
               console.log('Worker response:', event.data);
           };
       }
    };
    iframe_p.onload = () => {
        const iframeDocument = iframe.contentDocument || iframe.contentWindow.document;
        const iframeCanvas = iframeDocument.getElementById('sc-canvas');

        if (iframeCanvas) {
            // Transfer the content of iframe's canvas to OffscreenCanvas
            const offscreenCanvas = iframeCanvas.transferControlToOffscreen();

            // Send the OffscreenCanvas to the worker
            const worker = new Worker('offscreen-worker.js');
            worker.postMessage({ canvas: offscreenCanvas }, [offscreenCanvas]);

            worker.onmessage = function(event) {
               console.log('Worker response:', event.data);
           };
       }
    };
    iframe_s.onload = () => {
        const iframeDocument = iframe.contentDocument || iframe.contentWindow.document;
        const iframeCanvas = iframeDocument.getElementById('sc-canvas');

        if (iframeCanvas) {
            // Transfer the content of iframe's canvas to OffscreenCanvas
            const offscreenCanvas = iframeCanvas.transferControlToOffscreen();

            // Send the OffscreenCanvas to the worker
            const worker = new Worker('offscreen-worker.js');
            worker.postMessage({ canvas: offscreenCanvas }, [offscreenCanvas]);

            worker.onmessage = function(event) {
               console.log('Worker response:', event.data);
           };
       }
    };


    // Build the encounter area based on JSON data
    function initEncounter() {

      const encounterStatsDiv = document.getElementById('encounterStats');
      const stats = jsonData.encounter.stats;
      for (let key in stats) {
        const statDiv = document.createElement('div');
        if (key === "icon") {
          const iconImg = document.createElement('img');
          iconImg.src = stats[key];
          iconImg.alt = "Icon";
          statDiv.appendChild(iconImg);
        } else {
          statDiv.textContent = key + ": " + stats[key];
        }
        encounterStatsDiv.appendChild(statDiv);
      }
    }

    // Build the player area based on JSON data
    function initPlayer() {

      const playerStatsDiv = document.getElementById('playerStats');
      const stats = jsonData.player.stats;
      for (let key in stats) {
        const statDiv = document.createElement('div');
        if (key === "icon") {
          const iconImg = document.createElement('img');
          iconImg.src = stats[key];
          iconImg.alt = "Icon";
          statDiv.appendChild(iconImg);
        } else {
          statDiv.textContent = key + ": " + stats[key];
        }
        playerStatsDiv.appendChild(statDiv);
      }
    }

    // Build the stage area based on JSON data
    function initStage() {
      const stageArea = document.getElementById('stageArea');

      // Render parallax background layers
      jsonData.stage.parallax.forEach(layer => {
        const layerDiv = document.createElement('div');
        layerDiv.classList.add('parallax-layer');
        layerDiv.style.zIndex = layer.layer;
        layerDiv.style.backgroundImage = "url('" + layer.image + "')";
        stageArea.appendChild(layerDiv);
      });

      // Render stage puppets (full-body animated characters)
      jsonData.stage.puppets.forEach(puppet => {
        const img = document.createElement('img');
        img.src = puppet.image;
        img.id = puppet.id;
        img.classList.add('stage-puppet');
        for (let prop in puppet.position) {
          img.style[prop] = puppet.position[prop];
        }
        stageArea.appendChild(img);
      });

      // Render objects with clickable areas
      jsonData.stage.objects.forEach(obj => {
        const img = document.createElement('img');
        img.src = obj.image;
        img.id = obj.id;
        img.style.position = "absolute";
        for (let prop in obj.position) {
          img.style[prop] = obj.position[prop];
        }
        img.addEventListener('click', function() {
          alert("Clicked on object: " + obj.id);
        });
        stageArea.appendChild(img);
      });
    }

    // Build the dialog area based on JSON data
    function initDialog() {
      const dialogDiv = document.getElementById('dialog');
      const p = document.createElement('p');
      p.textContent = jsonData.dialog.text;
      dialogDiv.appendChild(p);

      jsonData.dialog.buttons.forEach(buttonData => {
        const btn = document.createElement('button');
        btn.textContent = buttonData.text;
        btn.addEventListener('click', function() {
          eval(buttonData.action);
        });
        dialogDiv.appendChild(btn);
      });
    }

    // Example action functions
    function attack() {
      alert("Attack action triggered!");
    }
    function defend() {
      alert("Defend action triggered!");
    }

    window.onload = function() {
      initEncounter();
      initPlayer();
      initStage();
      initDialog();

      // Create a horizontal split for the three main sections:
      // Column 1 and 3: 12.5% each; Column 2: 75%
      Split(['#encounter', '#stage', '#player'], {
        gutterSize: 5,
        minSize: 150,
        sizes: [12.5, 75, 12.5]
      });

      // Allow the horizontal split to settle then compute vertical sizes
      const stageContainer = document.getElementById('stage');
      const containerHeight = stageContainer.clientHeight;
      // Set dialog default height to 1/8th the total window width (in pixels)
      let dialogDefault = window.innerWidth / 8;
      // Ensure dialogDefault is not larger than half the stage height
      if(dialogDefault > containerHeight * 0.5) {
        dialogDefault = containerHeight * 0.5;
      }
      const dialogPercent = (dialogDefault / containerHeight) * 100;
      const stageAreaPercent = 100 - dialogPercent;

      // Create a vertical split for the stage area and dialog area
      Split(['#stageArea', '#dialog'], {
        gutterSize: 5,
        direction: 'vertical',
        minSize: [50, 50],
        sizes: [stageAreaPercent, dialogPercent]
      });
      const iframe = document.getElementById('stageIframe');
      setInterval(keepIframeFocused, 100);

    // Function to keep the iframe focused
    function keepIframeFocused() {
      if (document.activeElement !== iframe) {
        iframe.focus();
      }
    }
    }
  </script>
</body>
</html>
